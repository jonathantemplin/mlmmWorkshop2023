<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.361">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="multilevel-measurement-models-workshop-2023" class="level1">
<h1>Multilevel Measurement Models Workshop 2023</h1>
<section id="instructors-lesa-hoffman-and-jonathan-templin" class="level2">
<h2 class="anchored" data-anchor-id="instructors-lesa-hoffman-and-jonathan-templin">Instructors: <a href="https://lesahoffman.com">Lesa Hoffman</a> and <a href="https://jonathantemplin.com">Jonathan Templin</a></h2>
<p>This repository contains the materials for the Multilevel Measurement Models Workshop 2023, given 27-30 June 2023 at the Universität Mannheim as part of the Statistical Modeling in Psychology training group. Details about the event can be found at <a href="https://www.uni-mannheim.de/smip-summerschool/">https://www.uni-mannheim.de/smip-summerschool/</a>.</p>
<p>Workshop videos are available via YouTube at <a href="https://www.youtube.com/playlist?list=PLSmMs4UgmSMgay00hLnxQNsZHNXN8_ZIt">https://www.youtube.com/playlist?list=PLSmMs4UgmSMgay00hLnxQNsZHNXN8_ZIt</a>.</p>
<section id="repository-information" class="level3">
<h3 class="anchored" data-anchor-id="repository-information">Repository Information</h3>
<p>The folder structure of the repository is set to correspond with the analysis files found in the root folder. All other paths for necessary files are relative.</p>
<p>Please note, Stan output files (the empty model folder) are not included in the repository. These files will be created when the models are run.</p>
</section>
</section>
<section id="workshop-description" class="level2">
<h2 class="anchored" data-anchor-id="workshop-description">Workshop Description</h2>
<p>This workshop will focus on the use of latent variable measurement models in multilevel sampling designs (e.g., persons within clusters, occasions within persons, stimuli crossed with persons). Course time will be allocated to traditional lectures, guided practice building models, and opportunities for individual data analysis (or further independent practice through instructor-provided data analysis activities). Day 1 will focus on latent variable measurement models for normal, binary, and ordinal responses (all in slope–intercept form) and introduce Stan for MCMC estimation. Day 2 will present concepts of multilevel models using observed outcomes and transition into three-level models for item responses nested in persons nested in clusters. Day 3 will extend multilevel models to include latent variable measurement models with level-specific discrimination parameters. Finally, Day 4 will make connections to models in which item parameters are treated as random effects instead of fixed effects (i.e., for predicting sources of item difficulty and discrimination, as in explanatory item response models). All instructional sessions will be recorded for future participant use.</p>
<p>Prerequisite knowledge and skills include: (1) familiarity with R software for data analysis, (2) some familiarity with Markov Chain Monte Carlo (MCMC) estimation (i.e., have estimated models with MCMC before), (3) some prior knowledge of latent variable measurement models (i.e., confirmatory factor analysis for continuous responses; item response theory for binary and ordinal responses), and (4) some prior knowledge of multilevel models (i.e., hierarchical linear models, mixed-effects models). The course will use Stan software as run through R (using CMDStanR), but no prior experience with Stan is assumed. Participants who wish to use their own devices during the workshop should install Stan ahead of time. No readings will be required ahead of time.</p>
</section>
</section>
<section id="guide-to-workshop-scripts" class="level1">
<h1>Guide to Workshop Scripts</h1>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Unit</th>
<th>Syntax</th>
<th>Results</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>01_Introduction_Bayes_Stan_IRT.docx</td>
<td></td>
<td>Quarto document with Word-formatted slides for Introduction to Bayesian Estimation with Stan</td>
</tr>
<tr class="even">
<td></td>
<td>01_unidimensionalIRT.R</td>
<td></td>
<td>R script for IRT models (Marginal ML and Bayesian)</td>
</tr>
<tr class="odd">
<td></td>
<td>01_model01.stan</td>
<td>01_model01.RData</td>
<td>Unidimenionsal 1PL Model</td>
</tr>
<tr class="even">
<td></td>
<td>01_model02.stan</td>
<td>01_model02.RData</td>
<td>Unidimenionsal 2PL Model (Standardized Factor)</td>
</tr>
<tr class="odd">
<td></td>
<td>01_model03.stan</td>
<td>01_model03.RData</td>
<td>Unidimenionsal 2PL Model (Maker Item Discrimination)</td>
</tr>
<tr class="even">
<td>02</td>
<td>02_Multilevel_Observed.pdf</td>
<td></td>
<td>PDF of slides for Multilevel (Observed) Models</td>
</tr>
<tr class="odd">
<td></td>
<td>02_mlm_Bayes.R</td>
<td></td>
<td>R script for Multilevel (Non-Measurement) Models with Bayesian Estimation</td>
</tr>
<tr class="even">
<td></td>
<td>02_mlm_ML.docx</td>
<td></td>
<td>R markdown output for Multilevel (Non-Measurement) Models with Maximum Likelihood Estimation</td>
</tr>
<tr class="odd">
<td></td>
<td>02_mlm_ML.R</td>
<td></td>
<td>R script for Multilevel (Non-Measurement) Models with Maximum Likelihood Estimation</td>
</tr>
<tr class="even">
<td></td>
<td>02_model01.stan</td>
<td>02_model01.RData</td>
<td>Empty (Non-Multilevel) Linear Model for Sum Score</td>
</tr>
<tr class="odd">
<td></td>
<td>02_model02.stan</td>
<td>02_model02a.RData</td>
<td>Random Intercept Model for Sum Score</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>02_model02b.RData</td>
<td>Multilevel Model of Sum Score with Free/Reduced Lunch Smushed</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>02_model02c.RData</td>
<td>Multilevel Model of Sum Score with Free/Reduced Lunch at L1 and L2</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>02_model02d.RData</td>
<td>Multilevel Model of Sum Score with Cluster Centered Free/Reduced Lunch at L1 and L2</td>
</tr>
<tr class="odd">
<td></td>
<td>02_model03.stan</td>
<td>02_model03.RData</td>
<td>Empty (Non-Multilevel) Generalized Linear Model for Free/Reduced Lunch Status</td>
</tr>
<tr class="even">
<td></td>
<td>02_model04.stan</td>
<td>02_model04.RData</td>
<td>Random Intercept Model for Free/Reduced Lunch Status</td>
</tr>
<tr class="odd">
<td></td>
<td>02_model05.stan</td>
<td>02_model05a.RData</td>
<td>Random Linear Slope Model for Free/Reduced Lunch Status</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>02_model05b.RData</td>
<td>Random Linear Slope Model for Free/Reduced Lunch Status with Cross-Level Interaction</td>
</tr>
<tr class="odd">
<td>03</td>
<td>03_Multilevel_Measurement.pdf</td>
<td></td>
<td>PDF of slides for Multilevel Measurement Models</td>
</tr>
<tr class="even">
<td></td>
<td>03_Multilevel_Measurement_Equations.docx</td>
<td>Multilevel measurement model equations and notation</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>03_mlmm.R</td>
<td></td>
<td>R script for Multilevel Measurement Models with Stan</td>
</tr>
<tr class="even">
<td></td>
<td>03_model01.stan</td>
<td>03_model01.RData</td>
<td>Empty (Non-Measurement) Two-Level Model with Correlated Random Item Intercepts</td>
</tr>
<tr class="odd">
<td></td>
<td>03_model02.stan</td>
<td>03_model02.RData</td>
<td>Within-School Measurement Model with Correlated Random Item Intercepts and Within-School Discriminations Fixed=1</td>
</tr>
<tr class="even">
<td></td>
<td>03_model03.stan</td>
<td>03_model03.RData</td>
<td>Within-School Measurement Model with Correlated Random Item Intercepts and Estimated Within-School Discriminations using Standardized Theta</td>
</tr>
<tr class="odd">
<td></td>
<td>03_model04.stan</td>
<td>03_model04.RData</td>
<td>Within-School Measurement Model with Correlated Random Item Intercepts and Estimated Within-School Discriminations using Item1=Marker</td>
</tr>
<tr class="even">
<td></td>
<td>03_model05.stan</td>
<td>03_model05.RData</td>
<td>Within-School and Between-School Measurement Model with Uncorrelated Random Item Intercepts and Estimated Level-Specific WS (Item1=Marker) and BS (Item10=Marker) Discriminations</td>
</tr>
<tr class="odd">
<td></td>
<td>03_model06.stan</td>
<td>03_model06.RData</td>
<td>Within-School and Between-School Measurement Model with Uncorrelated Random Item Intercepts and Estimated Level-Constrained WS (Item1=Marker) and BS (Item1=Marker) Discriminations</td>
</tr>
<tr class="even">
<td></td>
<td>03_model07.stan</td>
<td>03_model07.RData</td>
<td>Within-School and Between-School Measurement Model without Random Item Intercepts and with Estimated Level-Constrained WS (Item1=Marker) and BS (Item1=Marker) Discriminations</td>
</tr>
<tr class="odd">
<td></td>
<td>03_model08.stan</td>
<td>03_model08.RData</td>
<td>Within-School and Between-School Measurement Model with Uncorrelated Random Item Intercepts and Free/Reduced Lunch MLM Predictor and Estimated Level-Constrained WS (Item1=Marker) and BS (Item1=Marker) Discriminations</td>
</tr>
<tr class="even">
<td>Other</td>
<td>Other_Materials_from_Lesa_Hoffman.docx</td>
<td></td>
<td>Word document with additional materials from Lesa Hoffman</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>